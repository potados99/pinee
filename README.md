# 📌pinee📌

<img src="https://user-images.githubusercontent.com/35878712/102021709-14b21980-3dc5-11eb-9192-b4dc8470a6e2.png" alt="pinee" width="128"/>

메시지가 고정되면 아카이브 채널에 기록해주는 봇입니다.

## 설치

- ### [서버에 pinee 설치하기](https://discord.com/api/oauth2/authorize?client_id=786477765205426176&permissions=76880&scope=bot)

- [개발중인 pinee 테스트하기](https://discord.com/api/oauth2/authorize?client_id=786876831181045781&permissions=76880&scope=bot)

## 사용

### *pinee*가 하는 일

누군가가 메시지를 고정하면 해당 메시지를 아카이브 채널로 복사합니다.

> *"어떤 채널에다가 복사하나요?"*

토픽에 '[아카이브](https://github.com/potados99/tarvern-pin-archiver/blob/9bb1824ac8eabbf4ffd4d8dc7bdffb9b322e0e18/config.ts#L29)'라는 단어가 들어 있는 채널을 사용합니다.

> *"그런 채널이 없으면요?"*

메시지를 옮길 일이 생기면 *pinee*가 새 채널을 생성할지 물어봅니다. 이때 자동으로 만들어주는 채널을 사용할 수 있습니다. 채널을 미리 만들어 놓는 것도 좋습니다.

> *"*pinee* 설치 전에 있던 고정 메시지들은요?"*

`!!싱크` 명령을 쓰면 이전에 있던 메시지들도 옮겨줍니다. 몇 가지 옵션을 지정할 수 있습니다. 자세한 내용은 아래에서 다뤄용.

> *"실수로 메시지가 날아간다든가도 할 수 있나요?"*

원본은 건드리지 않습니다. *pinee*는 자기가 보낸 메시지만 수정/삭제합니다.

> *"망하면 복구할 수 있나요?"*

변경 사항은 아카이브 채널에만 생깁니다. 원본이 존재하는 한 아카이브 채널은 얼마든지 만들고 `!!싱크`할 수 있습니다.

> *"고정한 메시지를 고정 해제하면 어떻게 되나요?"*

아무 일 안 생깁니다. 아카이브 채널에 그대로 남아 있습니다.

> *"그럼 삭제하면요?"*

삭제해도 그대로 남아있습니다.

> *"그럼..메시지 내용을 수정하면요?"*

실시간으로 반영됩니다. 해당 메시지의 복사본을 아카이브 채널에서 찾아서 최신 내용으로 업데이트합니다.

> *"NSFW 채널에서 메시지 고정하면 누구나 다 볼 수 있나요?"*

선택할 수 있습니다. 고정 직후 *pinee*가 해당 메시지를 아카이브 채널로 복사할 것인지 묻습니다. ✅ 리액션을 추가하면 승인으로 간주하고 아카이브합니다.

### 명령어

다음 명령을 지원합니다.

#### !!싱크

> 이 명령은 서버 owner만 실행할 수 있습니다.

현존하는, 또는 현존했던 모든 고정 메시지를 아카이브합니다.

다음 세 가지 옵션을 지원합니다:

- `비공개 또는 NSFW 채널의 메시지 포함하기`: 접근이 제한되는 채널의 메시지도 아카이브합니다.
- `고정 해제된 메시지 포함하기`: 고정 해제된 메시지라도 고정했던 기록은 남습니다. 이 기록에 기반하여 한 번이라도 고정된 적 있는 모든 메시지를 아카이브합니다.
- `백업 덮어쓰기`: 아카이브 채널에 존재하는 모든 복사본(아카이브)을 지운 후 새로 아카이브합니다. 아카이브된 메시지의 순서가 바로잡아지기 때문에 좋습니다.

> *"시스템이 남겨 놓은 고정 기록을 지우면 어떻게 되나요?"*

`고정 해제된 메시지 포함하기` 옵션을 켠 상태라면 아카이브할 메시지를 찾을 때 **시스템의 고정 기록에 의존**합니다. 

따라서 고정 기록이 없으면 현재 메시지가 고정된 상태라도 찾지 못합니다. 고정 기록이 없지만 현재 고정된 메시지를 아카이브하려면 해당 옵션을 끄면 됩니다.

~~그냥 고정 기록을 지우지 마세여!!~~

> *"백업 덮어쓰면 아카이브 채널 자체가 지워지는 건가요?"*

해당 채널에서 *pinee*가 작성한 아카이브 메시지만 지웁니다.

> *"pinee가 만든 아카이브랑 다른 일반 메시지를 어떻게 구분하나요?"*

아카이브 메시지는 다음과 같은 특징이 있습니다:

- *pinee*가 작성했다.
- 아카이브 채널에 위치한다.
- 메시지에 embed가 들어가 있다.
- 해당 embed의 author 필드에 url이 있다.
- 그 url은 `https://discordapp.com/channels/${서버ID}/${채널ID}/${메시지ID}` 형식을 띤다.

위와 조건을 만족하는 메시지만 '*pinee*가 작성한 아카이브'로 간주됩니다.

> *"만약 이미 존재하는 아카이브 채널을 보존하고 싶다면 어떻게 하면 되나요?"*

해당 아카이브 채널의 토픽에서 '아카이브'라는 단어를 제거해 주세요. 그러면 *pinee*가 더 이상 그 채널을 아카이브 채널로 인식하지 않게 됩니다. 

이렇게 하면 아카이브 채널이 없던 맨 처음 상태와 같아집니다. 새 채널을 만들거나 *pinee*가 만들어주는 채널을 이용해 `!!싱크`를 진행하시면 됩니다.

> *"싱크는 오래 걸리나요?"*

메시지 전송 빈도 제한이 있어 조금 오래 걸립니다 ㅎㅎ

## 권한

다음 권한을 사용합니다.

- `Manage Channels`: 아카이브 채널을 만들기 위해 사용합니다.
- `View Channels`: 전체 채널 중 아카이브 채널을 찾기 위해 사용합니다.
- `Send Messages`: 아카이브 채널에서 메시지를 보내기 위해 사용합니다.
- `Manage Messages`: 보낸 메시지를 수정하기 위해(진행상태 표시 등) 사용합니다.
- `Read Message History`: 지난 고정 메시지들을 가져오기 위해 사용합니다.
- `Add Reaction`: 사용자에게 계속할 것인지 물을 때에 예시 리액션(✅, ❌)을 추가하기 위해 사용합니다.

## 기타

> *"*pinee*는 어디에 사나요?"*

미국에 삽니다.

> *"서버 비용은요?"*

무료입니다.

## 업데이트 로그

### 2020.12.20 v1.2.0
- API 문제에 안전하게 대응.
- 발견한 고정메시지 캐싱.

### 2020.12.20 v1.1.3
- 메모리 효율 개선.

### 2020.12.14 v1.1.2
- Discord API의 메시지 fetch 최대 100개 제한 대응.
- 메시지 가져올 때에 진행상황 표시.
- 최종 확인할 때에 `onlyForOwner` 옵션을 활성화시키지 않은 어이없는 버그 수정.

### 2020.12.14 v1.1.1
- 용어 약간 변경.
- DM 왔을때 답장함.
- 로그 메시지 이제 쓸모있어짐.

### 2020.12.12 v1.1.0
- 메시지 원본으로 건너뛰는 링크 추가.
- 고정메시지 변경에 실시간으로 대응.
- 개선된 아카이브 명령 `!!싱크` 제공.

### 2020.12.10 v1.0.0
- 새로 고정된 메시지 아카이브.
- 수동 아카이브 명령 `!!고정메시지모두백업` 제공.

## 프로젝트 구조

### 소스 구조

~~~
pinee/
  └ lib/           
    └ command/      → 명령어의 선언과 구현체.
    └ interactor/   → 사용자와 양방향 소통하는 루틴.
    └ repository/   → 채널, 메시지 등을 가져올 수 있는 저장소.
    └ responder/    → 이벤트에 대한 적절한 응답을 제공하는 응답기.
    └ routes/       → 이벤트를 처리하는 최상위 라우터.
    └ services/     → 복잡하고 오래 걸리는 이벤트 로직을 정의하는 서비스.
    └ utils/        → 구현에 필요한 유틸리티.
    bot.ts          → 봇의 기본 동작 정의.
  └ config.ts       → 설정 파일.
  ...
  └ package.json    → 프로젝트 정보.
  └ index.ts        → 프로그램의 진입점.
  └ README.md       → 이 문서.
~~~

### 실행 흐름

~~~
event 
    -> route 
        -> responder 
            -> command
                -> interactor
                -> utils
                -> ...
            -> service
                -> ...
            -> repository
                -> ...
~~~

이벤트가 발생하면 `bot.ts`에서 지정한 이벤트 리스너가 호출됩니다. 해당 리스너는 적절한 `router`를 호출합니다.

`router`는 요청의 유효성을 검증하는 역할을 합니다. 유효한 요청은 `responder`에게로 전달됩니다.

각 `responder`는 이벤트를 처리하기 위해 `command`, `service`에게 작업을 맡기거나 직접 `repository`에 접근하여 요청을 처리할 수 있습니다.

`command`, `service`, `repository`는 주어진 일을 수행하기 위해 `interactor`나 `utils`, 혹은 모두를 사용할 수 있습니다.